# 開發筆記

---

## Race Condition

### 什麼是 Race Condition？

Race Condition 是當兩個或以上的請求**幾乎同時**對同一筆資料進行操作，而導致資料處於一個「不預期的狀態」的情況。

白話來說：兩個請求都「以為」自己是第一個動手的，結果卻互相干涉，最後產生重複或錯誤的資料。

### 具體例子

以 BroTrip 的 `plan_votes` 為例，假設同一個使用者不小心快速按了兩次投票按鈕：

```
時間 T1：請求 A → SELECT WHERE (plan_id=1, profile_id=A) → 沒有記錄
時間 T1：請求 B → SELECT WHERE (plan_id=1, profile_id=A) → 沒有記錄
時間 T2：請求 A → INSERT → 成功 ✅
時間 T2：請求 B → INSERT → 也成功 ✅ ← 問題！同一人出現兩筆投票
```

兩個請求在幾乎相同的時間點都「讀到沒有記錄」，因此都認為需要 INSERT。結果 DB 裡出現了重複的資料。

### 怎麼避免？

| 方法 |說明 | 適用場景 |
|------|------|----------|
| **UNIQUE Constraint** | 在 DB 層設定某幾個欄位的組合不允許重複。第二個 INSERT 會被 DB 拒絕 | 防止重複數據（最基本的安全網）|
| **INSERT ... ON CONFLICT (upsert)** | INSERT 時偵測到冲突，自動轉為 UPDATE 而不是拋 error | 需要「插入或更新」的場景（如投票）|
| **Optimistic Locking** | 讀資料時帶回一個版本號，寫的時候帶著版本號，如果版本號不對就拒絕 | 更新複雜的資料，需要確保沒有人同時改過 |
| **前端 debounce / disable button** | 使用者點了按鈕後馬上禁用它，防止重複點擊 | 減少使用者不小心觸發的情況（但不能當安全網）|

> 前端的 debounce 只能減少發生的機率，不能當根本的解決方式。**真正的防範應該在 DB 層（UNIQUE constraint）或 API 層（upsert logic）。**

### 什麼時候應該考慮 Race Condition？

以下是幾個會觸發你「欸，這裡要不要處理 race condition」想法的信號：

1. **多個使用者可能同時操作同一張資料**
   - 例如：多個人同時投票、同時勾選 checklist item

2. **同一個使用者可能快速觸發兩次相同的操作**
   - 例如：快速雙擊按鈕、網路慢導致重複點擊、前端重新渲染後觸發

3. **操作模式是「先讀，再根據讀的結果寫」**
   - 這種 SELECT → 判斷 → INSERT/UPDATE 的模式本身就容易產生 race condition
   - 因為兩個請求可能在「讀」的階段都讀到相同的狀態

4. **涉及計數、累加、餘額等數值型數據**
   - 例如：票數累加、錢包餘額扣款
   - 如果兩個請求同時讀到「餘額 100」然後都扣 50，結果餘額變成 50 而不是 0

5. **數據有唯一性要求**
   - 例如：每個人只能投一票、每個 invite code 只能用一次
   - 這種場景都需要確保「唯一」這個約束在 DB 層被保證

---

## 該計算還是該存？（Computed vs Stored）

### 核心思考

這個問題的本質是：**這個值是「來源」還是「派生的」？**

- **來源（Source of Truth）**：這個值是直接由使用者輸入或外部系統產生的 → **存進去**
- **派生（Derived）**：這個值可以從 DB 裡其他已經存在的資料推導出來 → **考慮計算**

### 判斷標準

**優先選「計算」的信號：**
- 這個值可以從同一張或其他張表裡的資料直接推導出來
- 來源資料經常變動，如果存進去還要記得同步更新（維護負擔大，容易出sync bug）

**優先選「存」的信號：**
- 這個值經常被用來 WHERE 篩選或 ORDER BY 排序（計算太慢會影響性能）
- 來源資料可能會被刪除，但你還需要保留這個值的歷史紀錜
- 計算過程比較複雜或昂貴，頻繁計算會造成效能問題

### 用 BroTrip 的例子來對照

| 欄位 | 計算還是存？ | 為什麼 |
|------|------------|--------|
| `plans.status` | 計算 | 可以從 `plan_votes` 票數 + `approved_votes_number` 推導出來，來源經常變動 |
| `proposals.approved_votes_number` | 存 | 使用者設定的值，本身就是來源 |
| proposals 的參與人數 | 計算 | 可以從 `proposals_attendees` 直接 COUNT |
| `profiles.name` | 存 | 來源是 Google OAuth 回來的使用者資訊，本身就是來源 |
| checklist 的完成進度 | 計算 | 可以從 `checklist_item_status` 裡 COUNT checked 的數量推導 |

### 一個簡單的經驗法則

> 「這個值是不是完全由我 DB 裡**已經存在**的其他資料決定的？」
> 如果是 → 先考慮計算。
> 如果不是，或者計算昂貴 → 考慮存進去。

### 注意事項

即使選了「計算」，也不一定要每次都在應用層算。你還可以：
- 在 **後端 API** 裡算完再回傳給前端
- 用 **DB View** 來封裝計算邏輯（等於建一張虛擬表）
- 用 **DB Trigger** 在某張表發生變動時自動計算並更新（介於計算和存之間的折中）
